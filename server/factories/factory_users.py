"""
This module defines factories for user-related models, including SupportedLocales,
UserProfile, PendingUser, and RecoverPassword. It utilizes Factory Boy to generate test data
for Django models efficiently.
"""

import random
from datetime import timedelta

import factory
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.utils import timezone
from faker import Faker
from users.models import PendingUser, RecoverPassword, SupportedLocales, UserProfile
from users.signals import create_user_profile_from_user  # noqa: E402


def random_datetime_last_30_days(date_now_ref):
    """Generates a random datetime within the last 30 days from a given reference date."""
    start = date_now_ref - timedelta(days=30)
    random_date = start + random.random() * (date_now_ref - start)
    return random_date


class SupportedLocalesFactory(factory.django.DjangoModelFactory):
    """Factory for creating SupportedLocales instances with 
    predefined locale codes ('en-US', 'pt-BR')."""

    class Meta:
        model = SupportedLocales
        django_get_or_create = ("code",)  # Reuses existing locales instead of creating new ones

    code = factory.Iterator(["en-US", "pt-BR"])
    name = factory.LazyAttribute(lambda obj: f"Locale for {obj.code}")


class UserFactory(factory.django.DjangoModelFactory):
    """Factory for generating User instances with randomized usernames, 
    emails, first names, and activation statuses."""

    class Meta:
        model = User

    class Params:
        date_now_ref = timezone.now()

    username = factory.Faker("user_name")
    email = factory.Faker("email")
    first_name = factory.Faker("first_name")
    is_active = factory.Iterator([True, False])

    date_joined = factory.LazyAttribute(lambda o: random_datetime_last_30_days(o.date_now_ref))


class UserProfileFactory(factory.django.DjangoModelFactory):
    """Factory for producing UserProfile instances associated with User instances 
    and locales generated by SupportedLocalesFactory."""

    class Meta:
        model = UserProfile

    user = factory.SubFactory(UserFactory)
    locale = factory.SubFactory(SupportedLocalesFactory)


class PendingUserFactory(factory.django.DjangoModelFactory):
    """Factory for creating PendingUser instances representing users who have 
    registered but not yet confirmed their email. 
    Includes a fake UUID as an email token."""

    class Meta:
        model = PendingUser

    user_profile = factory.SubFactory(UserProfileFactory)
    email_token = factory.Faker("uuid4")


class RecoverPasswordFactory(factory.django.DjangoModelFactory):
    """Factory for generating RecoverPassword instances for users 
    requesting password resets, using a defined reference date 
    and setting an expiration date 5 days post-request."""

    class Meta:
        model = RecoverPassword

    class Params:
        date_now_ref = timezone.now()

    user = factory.SubFactory(UserFactory)
    email_token = factory.Faker("uuid4")
    requested_date = factory.LazyAttribute(lambda o: random_datetime_last_30_days(o.date_now_ref))
    expiration_date = factory.LazyAttribute(lambda o: o.requested_date + timedelta(days=5))


def create_supported_locales(n_sl):
    """Generates a specified number of SupportedLocales instances."""
    return [SupportedLocalesFactory.create() for _ in range(n_sl)]


def create_user(n_users, seed, date_now_ref):
    """Generates a specified number of User instances with repeatable 
    data generation using a fixed seed."""
    random.seed(seed)
    Faker.seed(seed)
    post_save.disconnect(create_user_profile_from_user, sender=User)
    users = [UserFactory.create(date_now_ref=date_now_ref) for _ in range(n_users)]
    return users


def create_user_profile(users, locales):
    """Generates UserProfiles for given users, each associated with a 
    randomly chosen locale."""
    user_profiles = []
    for user in users:
        locale = random.choice(locales)
        user_profile = UserProfileFactory.create(user=user, locale=locale)
        user_profiles.append(user_profile)
    return user_profiles


def create_pending_user(user_profiles):
    """Generates PendingUser instances for user profiles with inactive users."""
    pending_users = []
    for user_profile in user_profiles:
        if not user_profile.user.is_active:
            pending_user = PendingUserFactory.create(user_profile=user_profile)
            pending_users.append(pending_user)
    return pending_users


def create_recover_password(users, n_users, seed, date_now_ref):
    """Generates password recovery instances for a sample of users using 
    a fixed seed for consistency."""
    random.seed(seed)
    Faker.seed(seed)
    users = random.sample(users, n_users)

    recover_passwords = []
    for user in users:
        recover_password = RecoverPasswordFactory.create(user=user, date_now_ref=date_now_ref)
        recover_passwords.append(recover_password)

    return recover_passwords


def generate_data_user(n_user, n_recover, date_now_ref):
    """Main function to generate comprehensive user-related data and prepare 
    it for export, ensuring repeatable results with fixed seeding."""
    
    supported_locales = create_supported_locales(2)
    user = create_user(n_user, 0, date_now_ref)
    user_profile = create_user_profile(user, supported_locales)
    pending_user = create_pending_user(user_profile)
    recover_password = create_recover_password(user, n_recover, 0, date_now_ref)

    data_to_write = {
        "users": {
            "user.json": user,
            "supported_locales.json": supported_locales,
            "user_profile.json": user_profile,
            "pending_user.json": pending_user,
            "recover_password.json": recover_password,
        }
    }

    return data_to_write
